<!DOCTYPE html>
<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body{margin: 0;}
			canvas{width: 100%; height: 100%}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/grassShaders.js"></script>
		<script src="js/planeShaders.js"></script>

		<script>
			//Include statistics
			(function(){var script=document.createElement('script');
			script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);
			requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};
			script.src='http://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()
			
			//Start clock
			var startTime = Date.now();
	
			//Scene + Camera
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);

			//Renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.setClearColor('grey');
			
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			//Geometries
			var geoPlane = new THREE.PlaneBufferGeometry(2000, 2000, 200, 200);
			var geoSphere = new THREE.SphereGeometry(10, 32, 32);
			var geoSkybox = new THREE.BoxGeometry(5000, 5000, 5000);
			
			//Instances of grass
			var nGrass = 200000;
			var offsets = new Float32Array(nGrass*3);
			var rotations = new Float32Array(nGrass);
			for(i = 0; i < nGrass; ++i){
				//Distribute the blades of grass "evenly" across the plane
				offsets[i*3] = Math.random() * 2000 - 1000;
				offsets[i*3+1] = 5;
				offsets[i*3+2] = Math.random() * 2000 - 1000;
				rotations[i] = Math.random() * 2 * Math.PI;
			}
			
			//Experiment
			//Build vertices on shape of grass
			var vertices = new Float32Array( [
				  1.0, 0.0,  0.0, //T1
				  0.7, 2.0,  0.0,
				  0.0, 0.0,  0.0,

				  0.7, 2.0,  0.0, //T2
				  0.0, 3.0,  0.0,
				  0.0, 0.0,  0.0,

				  0.7, 2.0,  0.0, //T3
				  0.5, 5.0,  0.0,
				  0.0, 3.0,  0.0,

				  0.9, 4.0,  0.0, //T4
				  0.5, 5.0,  0.0,
				  0.7, 2.0,  0.0,

				  0.9, 4.0,  0.0, //T5
				  0.8, 6.0,  0.0,
				  0.5, 5.0,  0.0,

				  0.0, 0.0,  0.0, //T6
				  0.0, 3.0,  0.0,
				 -0.3, 2.0,  0.0,

				 -0.3, 2.0,  0.0, //T7
				  0.0, 3.0,  0.0,
				 -0.1, 4.0,  0.0,

				 -0.3, 2.0,  0.0, //T8
				 -0.1, 4.0,  0.0,
				 -0.5, 5.0,  0.0,
			] );

 			//var geoGrass = new THREE.InstancedBufferGeometry().copy(new THREE.PlaneBufferGeometry(2, 8, 1));
 			var singleGrass = new THREE.BufferGeometry();
 			singleGrass.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
 			var geoGrass = new THREE.InstancedBufferGeometry().copy(singleGrass);
			geoGrass.setAttribute("grassPos", new THREE.InstancedBufferAttribute(offsets, 3, true));
			geoGrass.setAttribute("grassRot", new THREE.InstancedBufferAttribute(rotations, 1, true));
 			
			var grassText;// = new THREE.TextureLoader().load("http://192.168.1.196:8000/images/grass_sprite.png");

			// instantiate a loader
			var loader = new THREE.TextureLoader();

			// load a resource
			loader.load(
				// resource URL
				'images/grass_sprite.png',
				// onLoad callback
				function ( texture ) {
					// in this example we create the material when the texture is loaded
					grassText = texture;
					grassText.wrapS = THREE.ClampToEdgeWrapping;
					grassText.wrapT = THREE.ClampToEdgeWrapping;
				},
				// onProgress callback currently not supported
				undefined,
				// onError callback
				function ( err ) {
					console.error('An error happened.');
				}
			);

 			/*Keep
			var geoGrass = new THREE.InstancedBufferGeometry().copy(new THREE.BoxBufferGeometry(0.5, 10, 0.5));
			geoGrass.addAttribute("grassPos", new THREE.InstancedBufferAttribute(offsets, 3, 1));
			*/
			
			//Fog
			scene.fog = new THREE.Fog('grey', 0.0, 1000.0);
			
			//Materials
			var uniforms = THREE.UniformsUtils.merge([
				THREE.UniformsLib['lights'],
				{ 
					diffuse: { type: 'c', value: new THREE.Color(0xffffff) },
					time:    { type: "f", value: 1.0 },
					fogColor:{ type: "c", value: scene.fog.color },
				    fogNear: { type: "f", value: scene.fog.near },
				    fogFar:  { type: "f", value: scene.fog.far },
				    texture: { type: "t", value: grassText},
				}
			]);

			var shaderMat = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertexShaderPlane,
				fragmentShader: fragmentShaderPlane,
				lights: true,
				fog: true,
				transparent: true,
			});
			var sphereMat = new THREE.MeshBasicMaterial('white');
			var matArray = [];
			var skyboxText = [
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('images/green_ft.tga'), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('images/green_bk.tga'), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('images/green_up.tga'), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('images/green_dn.tga'), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('images/green_rt.tga'), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('images/green_lf.tga'), side: THREE.DoubleSide}),
			];
			matArray.push(skyboxText);
			
			var grassMat = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertexShaderGrass,
				fragmentShader: fragmentShaderGrass,
				side: THREE.DoubleSide,
				lights: true,
				fog: true,
			});

			//Grass
			var grass = new THREE.Mesh(geoGrass, grassMat);
			scene.add(grass);

			//Skybox
			skybox = new THREE.Mesh(geoSkybox, matArray);
			scene.add(skybox);

			//Plane
			var plane = new THREE.Mesh(geoPlane, shaderMat);
			plane.rotation.x -= Math.PI/2;
			scene.add(plane);
			
			//Sphere
			var sphere = new THREE.Mesh(geoSphere, sphereMat);
			sphere.position.set(0.0, 500.0, 0.0);
			scene.add(sphere);

			//Lights
			var light = new THREE.PointLight(0x7B7900, 0.5, 20);
			light.position.set(0.0, 500.0, 0.0);
			scene.add(light);

			//Controls
			var controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.maxPolarAngle = Math.PI/3.0; controls.minPolarAngle = Math.PI/3.0;
			controls.enablePan = false; controls.enableZoom = false;

			//Set camera position
			camera.position.set(0, 300, 300);
			controls.update();
			
			//Rendering loop
			var animate = function () {
				var elapsedMilliseconds = Date.now() - startTime;
			    var elapsedSeconds = elapsedMilliseconds / 1000.0;
			    uniforms.time.value = 60.0 * elapsedSeconds;
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			};

			animate();
		</script>
	</body>
</html>