<!DOCTYPE html>
<html>
	<head>
		<title>Procedural terrain</title>
		<style>
			body{margin: 0;}
			canvas{width: 100%; height: 100%}
		</style>
		<script type="text/javascript" src="js/dat.gui.min.js"></script>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/grassShaders.js"></script>
		<script src="js/planeShaders.js"></script>

		<script>
			//Include statistics
			(function(){var script=document.createElement('script');
			script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);
			requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};
			script.src='http://mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()
			
			//Start clock
			var startTime = Date.now();
	
			//Scene + Camera
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);

			//Renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.setClearColor('grey');
			
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			//Geometries
			var geoPlane = new THREE.PlaneBufferGeometry(2000, 2000, 200, 200);
			var geoSphere = new THREE.SphereGeometry(10, 32, 32);
			var geoSkybox = new THREE.BoxGeometry(5000, 5000, 5000);
			
			//Instances of grass
			var nGrass = 200000;
			var offsets = new Float32Array(nGrass*3);
			var rotations = new Float32Array(nGrass);
			for(i = 0; i < nGrass; ++i){
				//Distribute the blades of grass "evenly" across the plane
				offsets[i*3] = Math.random() * 2000 - 1000;
				offsets[i*3+1] = 5;
				offsets[i*3+2] = Math.random() * 2000 - 1000;
				rotations[i] = Math.random() * 2 * Math.PI;
			}
			
			//Experiment
			//Build vertices on shape of grass
			var vertices = new Float32Array( [
				  1.0, 0.0,  0.0, //T1
				  0.7, 2.0,  0.0,
				  0.0, 0.0,  0.0,

				  0.7, 2.0,  0.0, //T2
				  0.0, 3.0,  0.0,
				  0.0, 0.0,  0.0,

				  0.7, 2.0,  0.0, //T3
				  0.5, 5.0,  0.0,
				  0.0, 3.0,  0.0,

				  0.9, 4.0,  0.0, //T4
				  0.5, 5.0,  0.0,
				  0.7, 2.0,  0.0,

				  0.9, 4.0,  0.0, //T5
				  0.8, 6.0,  0.0,
				  0.5, 5.0,  0.0,

				  0.0, 0.0,  0.0, //T6
				  0.0, 3.0,  0.0,
				 -0.3, 2.0,  0.0,

				 -0.3, 2.0,  0.0, //T7
				  0.0, 3.0,  0.0,
				 -0.1, 4.0,  0.0,

				 -0.3, 2.0,  0.0, //T8
				 -0.1, 4.0,  0.0,
				 -0.5, 5.0,  0.0,
			] );

 			//Grass
 			var singleGrass = new THREE.BufferGeometry();
 			singleGrass.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
 			var geoGrass = new THREE.InstancedBufferGeometry().copy(singleGrass);
 			geoGrass.scale(4, 2, 4);
			geoGrass.setAttribute("grassPos", new THREE.InstancedBufferAttribute(offsets, 3, true));
			geoGrass.setAttribute("grassRot", new THREE.InstancedBufferAttribute(rotations, 1, true));
			
			//Fog
			scene.fog = new THREE.Fog('grey', 100, 1000);
			
			//Materials
			var uniforms = THREE.UniformsUtils.merge([
				THREE.UniformsLib['lights'],
				{ 
					diffuse: { type: 'c', value: new THREE.Color(0xffffff) },
					time:    { type: "f", value: 1.0 },
					vel:     { type: "f", value: 0.5 },
					fogColor:{ type: "c", value: scene.fog.color },
				    fogNear: { type: "f", value: scene.fog.near },
				    fogFar:  { type: "f", value: scene.fog.far },
				}
			]);

			var shaderMat = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertexShaderPlane,
				fragmentShader: fragmentShaderPlane,
				lights: true,
				fog: true,
				transparent: true,
			});
			var sphereMat = new THREE.MeshBasicMaterial('yellow');
			var matArray = [];
			
			var grassMat = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertexShaderGrass,
				fragmentShader: fragmentShaderGrass,
				side: THREE.DoubleSide,
				lights: true,
				fog: true,
			});

			//Grass
			var grass = new THREE.Mesh(geoGrass, grassMat);
			scene.add(grass);

			//Plane
			var plane = new THREE.Mesh(geoPlane, shaderMat);
			plane.rotation.x -= Math.PI/2;
			scene.add(plane);
			
			//Sphere
			var sphere = new THREE.Mesh(geoSphere, sphereMat);
			sphere.position.set(0.0, 500.0, 0.0);
			scene.add(sphere);

			//Lights
			var light = new THREE.PointLight('yellow', 0.2, 20);
			light.position.set(0.0, 500.0, 0.0);
			scene.add(light);

			//Controls
			var controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.maxPolarAngle = Math.PI/3.0; controls.minPolarAngle = Math.PI/3.0;
			controls.enablePan = false; controls.enableZoom = false;

			//Set camera position
			camera.position.set(0, 300, 300);
			controls.update();

			var parameters = {
				velocity: 0.5,
				reset: function() {reset()},
			};

			function reset(){
				parameters.velocity = 0.5;
				uniforms.vel.value = 0.5;
			}

			var gui = new dat.GUI();
			var options = gui.addFolder('Options');
			gui.add(parameters, 'reset').name("Reset");
			var velo = options.add(parameters, 'velocity').min(0.0).max(1.0).step(0.1).listen();
			options.open();

			velo.onChange(function(value) {
				uniforms.vel.value = value;
				console.log(uniforms.vel.value);
			});
						
			//Rendering loop
			var animate = function () {
				var elapsedMilliseconds = Date.now() - startTime;
			    var elapsedSeconds = elapsedMilliseconds / 1000.0;
			    uniforms.time.value = 60.0 * elapsedSeconds;
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			};

			animate();
		</script>
	</body>
</html>