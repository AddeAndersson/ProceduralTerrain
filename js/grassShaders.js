var vertexShaderGrass = [
"#define USE_MAP true",
"vec4 mod289(vec4 x)",
"{",
"	return x - floor(x * (1.0 / 289.0)) * 289.0;",
"}",
"",
"vec4 permute(vec4 x)",
"{",
"	return mod289(((x*34.0)+1.0)*x);",
"}",
"",
"vec4 taylorInvSqrt(vec4 r)",
"{",
"	return 1.79284291400159 - 0.85373472095314 * r;",
"}",
"",
"vec2 fade(vec2 t) {",
"	return t*t*t*(t*(t*6.0-15.0)+10.0);",
"}",
"",
"// Classic Perlin noise",
"float cnoise(vec2 P)",
"{",
"	vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);",
"	vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);",
"	Pi = mod289(Pi); // To avoid truncation effects in permutation",
"	vec4 ix = Pi.xzxz;",
"	vec4 iy = Pi.yyww;",
"	vec4 fx = Pf.xzxz;",
"	vec4 fy = Pf.yyww;",
"",
"	vec4 i = permute(permute(ix) + iy);",
"",
"	vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;",
"	vec4 gy = abs(gx) - 0.5 ;",
"	vec4 tx = floor(gx + 0.5);",
"	gx = gx - tx;",
"",
"	vec2 g00 = vec2(gx.x,gy.x);",
"	vec2 g10 = vec2(gx.y,gy.y);",
"	vec2 g01 = vec2(gx.z,gy.z);",
"	vec2 g11 = vec2(gx.w,gy.w);",
"",
"	vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));",
"	g00 *= norm.x;",
"	g01 *= norm.y;",
"	g10 *= norm.z;",
"	g11 *= norm.w;",
"",
"	float n00 = dot(g00, vec2(fx.x, fy.x));",
"	float n10 = dot(g10, vec2(fx.y, fy.y));",
"	float n01 = dot(g01, vec2(fx.z, fy.z));",
"	float n11 = dot(g11, vec2(fx.w, fy.w));",
"",
"	vec2 fade_xy = fade(Pf.xy);",
"	vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);",
"	float n_xy = mix(n_x.x, n_x.y, fade_xy.y);",
"	return 2.3 * n_xy;",
"}",
"",
"",
"varying vec3 vNormal;",
"varying vec3 dispPos;",
"uniform float time;",
"uniform vec3 fogColor;",
"uniform float fogNear;",
"uniform float fogFar;",
"varying vec2 vUv;",
"",
"float findNoise(vec2 P)",
"{",
"	float fs = cnoise(4.0*P);",
"	fs += cnoise(8.0*P)/2.0;",
"",
"	return 100.0 * fs;",
"}",
"",
"vec2 findUV(vec2 P)",
"{",
"	return (P + 1000.0)/2000.0;",
"}",
"mat4 rotationY( in float angle ) {",
"	return mat4(  cos(angle),   0,    sin(angle), 0,",
"                     0,       1.0,      0,       0,",
"                -sin(angle),   0,    cos(angle), 0,",
"                     0,        0,        0,      1);",
"}",
"",
"attribute vec3 grassPos;",
"attribute float grassRot;",
"varying vec3 vPos;",
"varying vec3 pos;",
"uniform float vel;",
"",
"void main() {",
"	vUv = uv;",
"", //Combination of offsets and their original position
"	mat4 rot = rotationY(grassRot);",
"	vec3 comb = mat3(rot) * position;",
"	comb = comb + grassPos;",
"",
"", //cTime will move the grass along x
"	float cTime = mod(vel * 2.0 * time, 1000.0);",
"",  //Move grass along negative x
"	comb.x -= 2.0 * cTime;",
"",
"",	//If the grass gets close to end of the plane, reposition it
"",	//Avoid stretching the grass over the observable plane
"	if(comb.x < -990.0) comb.y -= 2000.0;",
"	if(comb.x < -1000.0) {comb.x += 2000.0; comb.y += 2000.0;}",
"",
"",	//Find corresponding uv coordinate for plane at grass's position
"",	//in order to find the displacement
"	vec2 mUV = findUV(vec2(comb.x, comb.z)) + vec2(vel * 0.002 * time, 0.0);",
"	float n = findNoise(mUV);",
"",
"",	//Add displacement height and flip sign of z(?)
"	dispPos = vec3(comb.x, comb.y + n, -comb.z);",
"",
"	vec4 modelViewPosition = modelViewMatrix * vec4( dispPos, 1.0 );",
"   pos = position;",
"	vPos = modelViewPosition.xyz;",
"	gl_Position = projectionMatrix * modelViewPosition;",
"",
"}"
].join("\n");
var fragmentShaderGrass = [
"#extension GL_OES_standard_derivatives : enable",
"#define USE_MAP true",
"uniform float time;",
"uniform vec3 fogColor;",
"uniform float fogNear;",
"uniform float fogFar;",
"uniform vec3 diffuse;",
"varying vec3 vPos;",
"varying vec3 pos;",
"varying vec2 vUv;",
"uniform sampler2D texture;",
"",
"struct PointLight {",
"	vec3 position;",
"	vec3 color;",
"};",
"",
"uniform PointLight pointLights[ NUM_POINT_LIGHTS ];",
"",
"void main()",
"{",
"",
"	vec3 ltGreen = vec3( 0.2, 0.5, 0.2);", //Light green
"	vec3 dkGreen = vec3(0.12, 0.38, 0.12);", //Dark green
"	gl_FragColor.rgb = mix(dkGreen, ltGreen, pos.y/12.0);", //The closer the ground the darker the color
"	float dist = distance(vPos, vec3(0.0, 0.0, 0.0));",
"", //Light contribution
"	for(int i = 0; i < NUM_POINT_LIGHTS; i++)",
"	{",
"		vec3 lightDirection = normalize(pointLights[i].position - vPos);",
"		gl_FragColor.rgb += clamp(dot(lightDirection, vec3(0.0, 1.0, 0.0)), 0.0, 1.0) * pointLights[i].color;",
"	}",
"",
"",
"", //Fog
"   #ifdef USE_FOG",
"   	#ifdef USE_LOGDEPTHBUF_EXT",
"   		float depth = gl_FragDepthEXT / gl_FragCoord.w;",
"   	#else",
"   		float depth = gl_FragCoord.z / gl_FragCoord.w;",
"   	#endif",
"   	float fogFactor = smoothstep(fogNear, fogFar, depth);",
"   	gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);",
"	#endif",
"}",
].join("\n");